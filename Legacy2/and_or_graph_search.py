"""Module providing the and_or_graph_search function."""

from action import Action
from failure import FAILURE
from path import Path
from problem import Problem
from state import State

ConditionalPlan = list[Action, dict[State, list]]

def and_or_graph_search(problem: Problem) -> ConditionalPlan:
    """Function for searching AND-OR graphs generated by nondeterministic environments. It returns\
       a conditional plan that reaches a goal state in all circumstances."""
    return or_search(problem.initial_state, problem, [])

def or_search(state: State, problem: Problem, path: Path) -> ConditionalPlan:
    """Function generating branches introduced by the agent's own choices, called OR nodes, in an\
       AND-OR graph."""

    if problem.goal_test(state):
        return []

    if state in path:
        return FAILURE

    for action in problem.actions(state):
        results = problem.result(state, action)
        path.insert(0, state)
        plan = and_search(results, problem, path)

        if plan is not FAILURE:
            plan.insert(0, action)

            return plan

    return FAILURE

def and_search(states: list[State], problem: Problem, path: Path) -> ConditionalPlan:
    """Function generating branches introduced by the environment's choice of outcome for each\
       action, called AND nodes, in an AND-OR graph."""

    plan = dict[State, ConditionalPlan]()

    for s_i in states:
        plan_i = or_search(s_i, problem, path)
        plan.update({s_i: plan_i})

        if plan_i is FAILURE:
            return FAILURE

    return [ plan ]
